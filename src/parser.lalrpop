use std::str::FromStr;
use crate::ast::*;
grammar;

// parses comma seperated list to a vector
Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub Program : Program = <Class*> => Program(<>); 

Class : Class = "class" <Identifier> "{" <Member*> "}";

Member : Member = {
    Constructor => Member::Constructor(<>),
    Method => Member::Method(<>),
    Field => Member::Field(<>)
}

Constructor : Constructor = <Identifier> "(" <Comma<Parameter>> ")" <Specification*> <Body>;

Method : Method = {
    "static" <Type> <Identifier> "(" <Comma<Parameter>> ")" <Specification*> <Body> => Method::Static((<>)),
    <Type> <Identifier> "(" <Comma<Parameter>> ")" <Specification*> <Body>  => Method::Nonstatic((<>)),
}

Parameter : Parameter = <Nonvoidtype> <Identifier>;

Specification : Specification = {
    "requires" "(" <VerificationExpression> ")" => Specification::Requires(<>),
    "ensures" "(" <VerificationExpression> ")" => Specification::Ensures(<>)
}

//TODO: how can i adhere to original grammar here?
// removing field gens conflict between field & method when evaluating class members
Field : Field = "-" <Nonvoidtype> <Identifier> ";";

Body : Statements = "{" <Statement+> "}";

Type : Type = {
    "void" => Type::Void,
    Nonvoidtype
}

Nonvoidtype : Type = {
    Primitivetype,
    Referencetype
}

Primitivetype : Type = {
    "int" => Type::Int,
    "bool" => Type::Bool 
}

Referencetype : Type = {
    ClassType,
    ArrayType
}

ClassType : Type = {
    <Identifier> => Type::ClassType(<>),
}

ArrayType : Type = {
    <Nonvoidtype> "[]" => Type::ArrayType(Box::new(<>))
}


pub Statements  = Statement*;

pub Statement : Statement = {
        DeclareAssign => Statement::DeclareAssign(<>),
        Declaration => Statement::Declaration(<>),
        Assignment => Statement::Assignment(<>),
        <Invocation> ";" => Statement::Call(<>),
        Skip => Statement::Skip(<>),
        Ite => Statement::Ite(<>),
        "return" <Expression> ";" => Statement::Return(<>),
        Block => Statement::Block(<>),
        Assert => Statement::Assert(<>),
        Assume => Statement::Assume(<>),
        While => Statement::While(<>)
}

DeclareAssign : DeclareAssign = {
    <t:Nonvoidtype> <id:Identifier> ":=" <r:Rhs> ";" => (<>)
}

Declaration : Declaration = {
    <l:Nonvoidtype> <r:Identifier> ";" => (<>)
}

Assignment : Assignment = {
    <l:Lhs> ":=" <r:Rhs> ";" => (<>) 
}

Lhs : Lhs = {
    Identifier => Lhs::Identifier(<>),
    <Identifier> "." <Identifier> => Lhs::AccessField(<>),
    <Identifier> "[" <Expression> "]" => Lhs::AccessArray(<>)
}

Rhs : Rhs= {
    Expression => Rhs::Expression(<>),
    <Identifier> "." <Identifier> => Rhs::AccessField(<>),
    <Identifier> "[" <Expression> "]" => Rhs::AccessArray(<>),
    Invocation => Rhs::Invocation(<>),
    "new" <Identifier> "(" <Arguments> ")" => Rhs::Newobject(<>),
    "new" <ClassType> "[" <Expression> "]" => Rhs::NewArray(<>),
    "new" <Primitivetype> "[" <Expression> "]" => Rhs::NewArray(<>)
}

Invocation : Invocation = {
    <Identifier> "." <Identifier> "(" <Arguments> ")" => (<>)
}

Arguments : Arguments = <Comma<Expression>>;

Skip : Skip = ";" => Skip;

Ite : Ite = {
    "if" "(" <e:Expression> ")" <s1:Statement> "else" <s2:Statement> => (e, Box::new(s1), Box::new(s2))
}

Block : Box<Statements> = {
    "{" <s:Statements> "}" => Box::new(<>)
}

Assert : Expression = {
    "assert" <s:VerificationExpression> ";" => <>
}

Assume : Expression = "assume" <VerificationExpression> ";";

While : While = "while (" <v:Expression> ")" <s : Statement>  => (v, Box::new(s));

Expression : Expression = {
    Expression2
}

pub VerificationExpression : Expression = Expression1;

Expression1 : Expression = {
    "forall" <id:Identifier> ":" <r:Expression1> => Expression::Forall(id, Box::new(r)),
    "exists" <id:Identifier> ":" <r:Expression1> => Expression::Exists(id, Box::new(r)),
    Expression2
}

Expression2 : Expression = {
    <l:Expression3> "==>" <r:Expression2> => Expression::Implies(Box::new(l), Box::new(r)),
    Expression3
}

Expression3 : Expression = {
    <l:Expression4> "&&" <r:Expression3> => Expression::And(Box::new(l), Box::new(r)),
    <l:Expression4> "||" <r:Expression3> => Expression::Or(Box::new(l), Box::new(r)),
    Expression4
}

Expression4 : Expression = {
    <l:Expression5> "==" <r:Expression4> => Expression::EQ(Box::new(l), Box::new(r)),
    <l:Expression5> "!=" <r:Expression4> => Expression::NE(Box::new(l), Box::new(r)),
    Expression5
}

Expression5 : Expression = {
    <l:Expression6> "<" <r:Expression5> => Expression::LT(Box::new(l), Box::new(r)),
    <l:Expression6> ">" <r:Expression5> => Expression::GT(Box::new(l), Box::new(r)),
    <l:Expression6> "<=" <r:Expression5> => Expression::LEQ(Box::new(l), Box::new(r)),
    <l:Expression6> ">=" <r:Expression5> => Expression::GEQ(Box::new(l), Box::new(r)),
    Expression6
}

Expression6 : Expression = {
    <l:Expression7> "+" <r:Expression6> => Expression::Plus(Box::new(l), Box::new(r)),
    <l:Expression7> "-" <r:Expression6> => Expression::Minus(Box::new(l), Box::new(r)),
    Expression7
}

Expression7 : Expression = {
    <l:Expression8> "*" <r:Expression7> => Expression::Multiply(Box::new(l), Box::new(r)),
    <l:Expression8> "/" <r:Expression7> => Expression::Divide(Box::new(l), Box::new(r)),
    <l:Expression8> "%" <r:Expression7> => Expression::Mod(Box::new(l), Box::new(r)),
    Expression8
}

Expression8 : Expression = {
    "-" <e:Expression8> => Expression::Negative(Box::new(<>)),
    "!" <e:Expression8> => Expression::Not(Box::new(<>)),
    Expression9
}

Expression9 : Expression = {
    Identifier => Expression::Identifier(<>),
    "#" <Identifier> => Expression::ArrLength(<>),
    Literal => Expression::Literal(<>),
    "(" <e:Expression> ")" => e
}


Literal : Literal = {
    Bool => Literal::Boolean(<>),
    Integer => Literal::Integer(<>),
}

Bool: bool = {
    "true" => true,
    "false" => false,
}

Integer: i64 = {
    r"[0-9]+" => i64::from_str(<>).unwrap()
};

Identifier: String = {
    r"[a-zA-Z]+[a-zA-Z0-9]*" => String::from_str(<>).unwrap()
}

match {
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { },
    _ // Skip `// comments`
}